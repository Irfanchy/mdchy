Start,    Input                //Asking for user input
          SkipCond 800         //If value is greater than 0 skip the next instruction
          Jump Pop             //Jump to pop value
          StoreI Stackpointer   //Store the value in stack indirectly
          JnS Incr             //Jump to increment
          Jump Start           //Repeat for other inputs
 //Pop subroutine
Pop,      LoadI Stackpointer    //Load Value from stackpointer indirectly 
          Store X             //Store the first value
          Jns Decr             //Jump to decrement again for second value
          LoadI Stackpointer    //Load Value from stackpointer indirectly 
          Store Y              //Store the value in Y
          Jump Count              //Jump to Count
//Push Subroutine

Push,     Load Result           //Load the Result value
          StoreI Stackpointer  //Store the value
          Jns Incr             //Jump to increment
	  Load Zero            //Load the constant value zero
          Store Result              //Store this value in R
          Jump Start           //Jump back to start of program
Count,    Load A                     //Load the new value 
          JnS Incrementoperator       //Jump to increment
          SkipCond 000                 //if value is negative skip the next instruction
          Jump Add                     //Jump to Add the value
          Load A                     //Load the new value again
          JnS Incrementoperator       // Jump to increment
          SkipCond 000                 //If the value is negative
          Jump Subt                    //Jump to subtract the value
          Load A                     //Load the new value
          JnS Incrementoperator       //Jump to increment
          SkipCond 000                 //If the value is Negative
          Jump Mul                     //Jump to multiply subroutine
          Jump Div                     //Jump to division subroutine

C,        LoadI Stackpointer           //Load the the value from stackpointer by indirect addressing
          Store A                    //Store this value in NV1
          Jns Decr                     //Jump to decrement
          Jump Pop                     //Jump to pop the value

//Increment Subroutine
          
Incr,     Hex 000              //Increment address
          Load Stackpointer    //Load the value at stack
          Add One              //Add one with the stack value
          Store Stackpointer   //Store it back to stack 
          JumpI Incr           //Jump back to push

//Decrement subroutine

Decr,     Hex 000              //Decrement address
          Load Stackpointer    //Load Stack
          Subt One             //Reduce one
          Store Stackpointer   //Store the value in stack 
          JumpI Decr           //Jump back to pop

Add,	 Load X			 // Load The value of X
	 Add Y			 // Add it with Y
	 Store Result		 // Store the addition	
	 Output Result		 // Display the result
	 Jump Push            //Jump to push the Result

Subt,	 Load X			//Load the value X
	 Subt Y			//Substract with Y
	 Store Result		//Store the result
	 Output Result		//display the result
         Jump Push              //Jump to push the Result 

Multiply, Load X 		//Load value of X
	  Store X		//Store it
	 Load Y			//Load value of Y
	 Store Y		//Store it
	 Skipcond 400		//Skip if input is 0 
	 JnS Mul 		//Jump to multiplication subroutine
	 Load Sum 		//Get result
	 Store Result 		//Result = X * Y
	 Output Result 		//Show the final result in output
	 Ctr, 	       Dec 0 	//Counter for looping
	 Sum, 	       Dec 0 	//Initial sum for multiplication
	 Mul, 	       Hex 0	//Store return address here
	 Load Y 		//Load second parameter to be used as counter
	 Store Ctr 		//Store as counter
	 Clear 			//Clear sum
	 Store Sum 		//Zero out the sum to begin
	 Loop, 	 Load Sum 		//Load the sum
	 Add X 			//Add first parameter
	 Store  Sum 		//Store result in Sum
	 Load  Ctr 		//Load the counter value
	 Subt One 		//Decrement counter by one
	 Store Ctr 		//Store counter
	 SkipCond  400 		//If counter = 0 finish subroutine
	 Jump Loop 		//Continue subroutine loop
	 JumpI Mul 		//Done with subroutine, return to main
	 Jump Push            //Jump to push the Result

Div,	 Load X
	 Store X
	 Load Y
	 Store Y
	 Skipcond 400		//Skip if input is 0
	 Hex 0	        	//entry point
         Clear                  //setting AC to 0
	 Store Result           //Make Result 0
Div1,    Load X                 //Loading the value of Dividend
         Subt Y	                //Subtracting the divisor from quotient
         Store X                //Storing the new value
         Load Result	        // Load the value from DivQt
         Add One		//incremet with one for the looping
         Store Result
         Load X 
         Skipcond 400          //Skip if its 0
	 Jump Div1             //Jump to Div1  
	 Jump Div2	       //Jump to Div2  
Div2,    Load Result	       //Load value of DivQt
         Store Result	       //Save the final result
	 Output Result	       // Show the result in output 
	 Jump Push            //Jump to push the Result

Incrementoperator,     Hex 000                 //Address
                       Load A              	//Load the new value
                       Add One                 //Add one
                       Store A                 //Store the new value
                       JumpI Incrementoperator   //Jump back to count
Stop,  	Halt   		    //End the program
	 
Stackpointer,  HEX A00           //Stackpointer Address
X,             Dec 0             //Constant value of X
Y,             Dec 0             //Constant value of Y
A,	       Dec 0		 //Constant value of A
Result,	       Dec 0		 //Constant value of Result
One,           Dec 1             //Value of One
Zero,          Dec 0      	 //Constant value 0